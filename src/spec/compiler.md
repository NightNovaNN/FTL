# FTL Compiler Specification

**Status:** Draft
**Scope:** Compiler behavior and guarantees
**Audience:** Compiler developers, auditors, advanced contributors

This document specifies the **required behavior** of the FTL compiler.
Any implementation claiming to be an FTL compiler **must follow this document**.

---

## 1. Purpose

The FTL compiler exists to transform valid FTL source code into executable bytecode in a way that is:

- Deterministic
- Auditable
- Safety-preserving

Any behavior not explicitly allowed by this specification is **forbidden**.

---

## 2. Compiler Pipeline Overview

An FTL compiler **MUST** implement the following stages in order:

```
Corona   → Preprocessing
Borealis → IR Construction
Quark    → Optimization
Photon   → Bytecode Generation
```

No stage may be skipped, reordered, or merged.

---

## 3. Stage 1: Corona (Preprocessing)

### 3.1 Responsibilities

Corona **MUST**:

- Normalize source input
- Resolve includes or dependencies (if supported)
- Reject malformed or ambiguous syntax early
- Produce a canonical source representation

### 3.2 Guarantees

- Output MUST be deterministic
- Output MUST NOT depend on execution environment
- Invalid input MUST cause compilation failure

### 3.3 Forbidden Behavior

Corona **MUST NOT**:

- Generate IR
- Perform optimization
- Infer programmer intent

---

## 4. Stage 2: Borealis (IR Construction)

### 4.1 Responsibilities

Borealis **MUST**:

- Convert preprocessed source into a structured IR
- Explicitly represent control flow
- Attach semantic and safety metadata

### 4.2 IR Properties

The IR **MUST** be:

- Fully explicit
- Deterministic
- Free of undefined behavior
- Auditable by humans

### 4.3 Guarantees

- Every valid source program produces exactly one IR
- Every IR node has well-defined semantics
- Unsafe constructs MUST be rejected

---

## 5. Stage 3: Quark (Optimization)

### 5.1 Responsibilities

Quark **MAY**:

- Transform IR to improve performance or size
- Remove redundant or unreachable structures

### 5.2 Optimization Rules

All optimizations **MUST**:

- Preserve program meaning
- Be deterministic
- Be provably safe

### 5.3 Forbidden Optimizations

Quark **MUST NOT**:

- Change observable behavior
- Introduce new side effects
- Rely on undefined behavior

If an optimization cannot be clearly justified, it **MUST NOT exist**.

---

## 6. Stage 4: Photon (Bytecode Generation)

### 6.1 Responsibilities

Photon **MUST**:

- Lower optimized IR into bytecode
- Enforce strict IR-to-bytecode mapping rules
- Emit deterministic output

### 6.2 Bytecode Properties

Generated bytecode **MUST** be:

- Platform-independent
- Fully specified
- Free of implicit behavior

### 6.3 Restrictions

Photon **MUST NOT**:

- Perform optimization
- Rewrite logic
- Infer semantics

Photon obeys the IR exactly.

---

## 7. Error Handling Model

FTL follows a **fail-fast** model.

| Condition                 | Required Action     |
| ------------------------- | ------------------- |
| Invalid source            | Compilation failure |
| Unsafe construct          | Compilation failure |
| Broken internal invariant | Immediate panic     |
| Non-fatal issue           | Warning             |

Compilation **MUST NOT** continue after fatal errors.

---

## 8. Determinism Requirements

An FTL compiler **MUST**:

- Produce identical output for identical input
- Not depend on system time, randomness, or environment state
- Not reorder transformations nondeterministically

---

## 9. Host Language Independence

While an implementation **MAY** be written in C or other languages:

- The behavior of the compiler MUST NOT depend on the host language
- No host-language UB may leak into FTL semantics

---

## 10. Conformance

A compiler is **FTL-conformant** if and only if:

- It follows all rules in this document
- It rejects all programs deemed invalid here
- It introduces no unspecified behavior

Anything else is **not FTL**.

---

## 11. Non-Goals

This specification explicitly excludes:

- JIT compilation
- Runtime code generation
- Speculative optimization
- Implicit execution models

---

## 12. Final Rule

If a behavior is:

- Not specified
- Not provably safe
- Not auditable

Then it **does not exist**.

---
